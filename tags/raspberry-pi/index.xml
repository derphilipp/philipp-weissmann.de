<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Raspberry Pi on Philipp Weißmann</title><link>https://philipp-weissmann.de/tags/raspberry-pi/</link><description>Recent content in Raspberry Pi on Philipp Weißmann</description><generator>Hugo -- gohugo.io</generator><language>de-de</language><lastBuildDate>Tue, 27 Aug 2019 18:28:54 +0000</lastBuildDate><atom:link href="https://philipp-weissmann.de/tags/raspberry-pi/index.xml" rel="self" type="application/rss+xml"/><item><title>yay mit archarm nutzen</title><link>https://philipp-weissmann.de/yay-mit-archarm-nutzen/</link><pubDate>Tue, 27 Aug 2019 18:28:54 +0000</pubDate><guid>https://philipp-weissmann.de/yay-mit-archarm-nutzen/</guid><description>Viele Entwickler schätzen es aktuelle Werkzeuge zu nutzen. Ob Compiler, Editor oder Shell - neue Versionen haben neue Features, bereinigte Bugs und mehr.
Daher ist in den letzten Jahren die Linux Distribution &amp;ldquo;Arch&amp;rdquo; auch sehr beliebt geworden: Rolling Releases statt großer Versionssprünge erleichtern den Entwickleralltag. Auch auf dem Raspberry Pi läuft diese Distribution.
Aus der Community getrieben Pakete können aus dem AUR mit einem beliebigen Tool installiert werden. Derzeit verwende ich dafür gerne yay.</description><content>&lt;p>Viele Entwickler schätzen es aktuelle Werkzeuge zu nutzen.
Ob Compiler, Editor oder Shell - neue Versionen haben neue Features, bereinigte Bugs und mehr.&lt;/p>
&lt;p>Daher ist in den letzten Jahren die Linux Distribution &amp;ldquo;Arch&amp;rdquo; auch sehr beliebt geworden: &lt;a href="https://de.wikipedia.org/wiki/Rolling_Release" title="Rolling Releases">Rolling Releases&lt;/a> statt großer Versionssprünge erleichtern den Entwickleralltag.
Auch auf dem Raspberry Pi läuft diese Distribution.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Aus der Community getrieben Pakete können aus dem &lt;a href="https://wiki.archlinux.org/title/Arch_User_Repository" title="AUR">AUR&lt;/a> mit einem beliebigen Tool installiert werden.
Derzeit verwende ich dafür gerne &lt;a href="https://github.com/Jguer/yay">yay&lt;/a>.&lt;/p>
&lt;p>Um &lt;code>yay&lt;/code> auf dem Raspberry Pi zu installieren, sind folgende Schritte notwendig:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Notwendige Pakete installieren&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo pacman -S git go make binutils gcc fakeroot
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># yay via git clonen und installieren&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git clone https://aur.archlinux.org/yay.git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd yay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>makepkg -si
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Dann steht der Installation von Paketen aus dem AUR nichts mehr im Wege.&lt;/p></content></item><item><title>SD Karte beschreiben mit „flash“</title><link>https://philipp-weissmann.de/sd-karte-beschreiben-mit-flash/</link><pubDate>Tue, 29 Nov 2016 08:30:27 +0000</pubDate><guid>https://philipp-weissmann.de/sd-karte-beschreiben-mit-flash/</guid><description>Um einen Raspberry Pi in Betrieb zu nehmen, ist es notwendig eine SD Karte mit einem Betriebssystem zu beschreiben.
Dabei ist es in der Regel nicht mit einem einfachen Datei kopieren getan.
Unter Windows bietet sich Win32 Disk Imager an,
unter macOS das Tool ApplePi Baker und unter Linux nutzt man einfach dd.
Nun wünscht man sich bei häufiger Nutzung ein einfaches Kommandozeilentool, dass diese Aufgabe komfortabel übernimmt.
Genau das erledigt das Tool flash.</description><content>&lt;p>Um einen Raspberry Pi in Betrieb zu nehmen, ist es notwendig eine SD Karte mit einem Betriebssystem zu beschreiben.&lt;br>
Dabei ist es in der Regel nicht mit einem einfachen Datei kopieren getan.&lt;/p>
&lt;p>Unter Windows bietet sich &lt;a href="https://sourceforge.net/projects/win32diskimager/">Win32 Disk Imager&lt;/a> an,&lt;br>
unter macOS das Tool &lt;a href="http://www.tweaking4all.com/software/macosx-software/macosx-apple-pi-baker/">ApplePi Baker&lt;/a> und unter Linux nutzt man einfach &lt;code>dd&lt;/code>.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Nun wünscht man sich bei häufiger Nutzung ein einfaches Kommandozeilentool, dass diese Aufgabe komfortabel übernimmt.&lt;/p>
&lt;p>Genau das erledigt das Tool &lt;a href="https://github.com/hypriot/flash">flash&lt;/a>.&lt;br>
Das in &lt;a href="https://de.wikipedia.org/wiki/Bash_(Shell)">bash&lt;/a> geschrieben Werkzeug ist schnell installiert:&lt;/p>
&lt;pre>&lt;code>curl -O https://raw.githubusercontent.com/hypriot/flash/master/$(uname -s)/flash
chmod +x flash
sudo mv flash /usr/local/bin/flash
&lt;/code>&lt;/pre>
&lt;p>Wie in der &lt;a href="https://github.com/hypriot/flash">Installationsanleitung auf Github&lt;/a> zu sehen, sind noch optionale Abhängigkeiten auf einige Tools zu installieren (u.a. &lt;code>curl&lt;/code>, &lt;code>pv&lt;/code>, &lt;code>unzip&lt;/code>).&lt;br>
Nach erfolgreicher Installation durch den Paketmanager des Vertrauens, können Raspberry Images geschrieben werden:&lt;/p>
&lt;pre>&lt;code>flash jessie-light.zip
&lt;/code>&lt;/pre>
&lt;p>Dabei übernimmt &lt;code>flash&lt;/code> das entpacken (bzw. Download) der Datei und fordert den Benutzer anschließend auf, die SD Karte einzulegen. Nach Identifizieren des Speichermediums braucht man lediglich selbiges zu bestätigen und der Schreibeprozess beginnt.&lt;/p>
&lt;p>Zum Abschluss des Ganzen werden auch alle Dateisystem ausgehängt und die Speicherkarte kann in den Raspberry Pi wandern.&lt;/p>
&lt;p>Für mich ist &lt;code>flash&lt;/code> &lt;em>das&lt;/em> Werkzeug zum Schreiben von SD Karten geworden.&lt;br>
Minimalistisch, komfortabel und einfach zu handhaben erleichtert mit das kleine Helferlein den Alltag.&lt;/p></content></item><item><title>Touch Display auf Raspberry Pi mit Arch Linux</title><link>https://philipp-weissmann.de/touch-display-auf-raspberry-pi-mit-arch-linux/</link><pubDate>Sun, 12 Apr 2015 12:28:29 +0000</pubDate><guid>https://philipp-weissmann.de/touch-display-auf-raspberry-pi-mit-arch-linux/</guid><description>&lt;p>Auf der Suche nach einem kleinen Display bin ich auf ein &lt;a href="https://github.com/watterott/RPi-Display">Display von Watterott&lt;/a> gestoßen.&lt;br>
Um das Gerät auf dem &lt;a href="https://www.raspberrypi.org/">Raspberry Pi&lt;/a> unter &lt;a href="http://archlinuxarm.org/">Arch Linux&lt;/a> zu betreiben sind einige Schritte notwendig.&lt;/p></description><content>&lt;p>Auf der Suche nach einem kleinen Display bin ich auf ein &lt;a href="https://github.com/watterott/RPi-Display">Display von Watterott&lt;/a> gestoßen.&lt;br>
Um das Gerät auf dem &lt;a href="https://www.raspberrypi.org/">Raspberry Pi&lt;/a> unter &lt;a href="http://archlinuxarm.org/">Arch Linux&lt;/a> zu betreiben sind einige Schritte notwendig.&lt;/p>
&lt;ol>
&lt;li>
&lt;p>Für alle Schritte nehme ich als User &lt;code>root&lt;/code> an&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&amp;ldquo;Normale&amp;rdquo; Arch Linux &lt;a href="http://web.archive.org/web/20150412224859/archlinuxarm.org/platforms/armv6/raspberry-pi">Installation auf dem Raspberry Pi durchführen&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hilfswerkzeug &lt;code>rpi-update&lt;/code> installieren:&lt;!-- raw HTML omitted -->
curl -L &amp;ndash;output /usr/bin/rpi-update &lt;a href="https://raw.githubusercontent.com/Hexxeh/rpi-update/master/rpi-update">https://raw.githubusercontent.com/Hexxeh/rpi-update/master/rpi-update&lt;/a> &amp;amp;&amp;amp; sudo chmod +x /usr/bin/rpi-update&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Kernel mit passenden Treibern installieren&lt;!-- raw HTML omitted -->
REPO_URI=https://github.com/notro/rpi-firmware rpi-update&lt;/p>
&lt;/li>
&lt;li>
&lt;p>X installieren&lt;!-- raw HTML omitted -->
pacman -S xorg-server xorg-xinit xorg-utils xorg-server-utils&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Optional: Tool zur Kalibrierung des Touch-Displays installieren&lt;!-- raw HTML omitted -->
pacman -S xinput_calibrator&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Konfigurationsdateien:&lt;br>
7.1. Am Ende &lt;code>/boot/config.txt:&lt;/code> einfügen:&lt;!-- raw HTML omitted -->
dtparam=spi=on
dtoverlay=rpi-display&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>7.2. Am Ende von `/etc/modules-load.d/raspberrypi.conf` einfügen:
snd-bcm2835
spi_bcm2708
fbtft_device
7.3. Datei `/etc/modprobe.d/fbtft.conf` anlegen und folgenden Inhalt
einfügen:
options fbtft_device name=mi0283qt-9a gpios=reset:23,led:18 speed=32000000 rotate=270
Achtung: Je nach Ausführung des Displays unterscheiden sich die
Parameter - einfach in die [Liste aufGithub][5]
schauen.
Achtung: Mit dem Parameter `rotate=270` dreht sich die Ausrichtung
des Displays
7.4. Datei `/etc/X11/xorg.conf.d/99-fbturbo.conf` anlegen und
folgenden Inhalt einfügen:
Section &amp;quot;Device&amp;quot;
Identifier &amp;quot;Allwinner A10/A13 FBDEV&amp;quot;
Driver &amp;quot;fbturbo&amp;quot;
Option &amp;quot;fbdev&amp;quot; &amp;quot;/dev/fb0&amp;quot;
Option &amp;quot;SwapbuffersWait&amp;quot; &amp;quot;true&amp;quot;
EndSection
7.5 Ans Ende der vorhandenen Datei `/etc/X11/xinit/xinitrc`
einfügen:
xinput --set-prop 'ADS7846 Touchscreen' 'Evdev Axes Swap' 1
xinput --set-prop 'ADS7846 Touchscreen' 'Evdev Axis Inversion' 0 1
Achtung: Hiermit dreht sich die Ausrichtung des Touch-Displays
passend zu den oben eingestellten 270 Grad; &amp;lt;/li&amp;gt;
* Reboot&amp;lt;/p&amp;gt;
reboot
* Nach dem Ausführen von&amp;lt;/p&amp;gt;
startx
sollte nun eine grafische Oberfläche auf dem kleinen Display laufen. &amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt;
&lt;/code>&lt;/pre></content></item></channel></rss>