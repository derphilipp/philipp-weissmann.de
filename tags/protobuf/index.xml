<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Protobuf on Philipp Weißmann</title><link>https://philipp-weissmann.de/tags/protobuf/</link><description>Recent content in Protobuf on Philipp Weißmann</description><generator>Hugo -- gohugo.io</generator><language>de</language><lastBuildDate>Sun, 09 Feb 2025 18:29:07 +0000</lastBuildDate><atom:link href="https://philipp-weissmann.de/tags/protobuf/index.xml" rel="self" type="application/rss+xml"/><item><title>GRPC, Protobuf und connect</title><link>https://philipp-weissmann.de/grpc-protobuf-connect/</link><pubDate>Sun, 09 Feb 2025 18:29:07 +0000</pubDate><guid>https://philipp-weissmann.de/grpc-protobuf-connect/</guid><description>&lt;h1 id="grpc-protobuf-und-connect">GRPC, Protobuf und Connect&lt;/h1>
&lt;p>Als Entwickler bin ich immer auf der Suche nach effizienten und zuverlässigen Technologien, die meine Arbeit verbessern und vereinfachen. In den letzten Jahren habe ich &lt;a href="https://grpc.io/">GRPC&lt;/a> in zahlreichen Projekten eingesetzt und bin nach wie vor begeistert von den Vorteilen, die es bietet.
Aber nicht nur weil es schnell und effizient ist - sondern weil es menschliche Absprachen und Teamarbeit einfacher macht.
Wie funktioniert das und warum &amp;ldquo;&lt;a href="https://connectrpc.com/">Connect&lt;/a>&amp;rdquo; noch mit reinspielt:&lt;/p></description><content>&lt;h1 id="grpc-protobuf-und-connect">GRPC, Protobuf und Connect&lt;/h1>
&lt;p>Als Entwickler bin ich immer auf der Suche nach effizienten und zuverlässigen Technologien, die meine Arbeit verbessern und vereinfachen. In den letzten Jahren habe ich &lt;a href="https://grpc.io/">GRPC&lt;/a> in zahlreichen Projekten eingesetzt und bin nach wie vor begeistert von den Vorteilen, die es bietet.
Aber nicht nur weil es schnell und effizient ist - sondern weil es menschliche Absprachen und Teamarbeit einfacher macht.
Wie funktioniert das und warum &amp;ldquo;&lt;a href="https://connectrpc.com/">Connect&lt;/a>&amp;rdquo; noch mit reinspielt:&lt;/p>
&lt;h2 id="was-ist-grpc">Was ist GRPC?&lt;/h2>
&lt;p>GRPC (gRPC Remote Procedure Call) ist ein modernes, leistungsstarkes Framework für Remote Procedure Calls (RPC), das von Google entwickelt wurde. Es ermöglicht es Anwendungen, Methoden auf entfernten Systemen so aufzurufen, als wären sie lokale Funktionen. GRPC nutzt HTTP/2 für den Transport und Protocol Buffers (Protobuf) als Serialisierungsformat. Mit anderen Worten: Binäre Batzen per UDP. Klingt schlimm - ist es aber gar nicht: Ich nehm euch mit!&lt;/p>
&lt;h2 id="was-ist-protobuf">Was ist Protobuf?&lt;/h2>
&lt;p>Protocol Buffers, oder kurz Protobuf, ist eine plattform- und sprachunabhängige Methode zur Serialisierung strukturierter Daten. Es wurde ebenfalls von Google entwickelt und dient als Grundlage für die Datenkommunikation in GRPC.&lt;/p>
&lt;p>Also:&lt;/p>
&lt;ul>
&lt;li>Protobuf = Datenformat&lt;/li>
&lt;li>GRPC = Kommunikationsprotokoll&lt;/li>
&lt;/ul>
&lt;h2 id="beispiel">Beispiel&lt;/h2>
&lt;p>Schauen wir uns ein einfaches Beispiel an.
Lasst uns ein einfaches Protobuf-File erstellen, der die Kommunikation mit einem Backofen darstellt.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-protobuf" data-lang="protobuf">&lt;span style="display:flex;">&lt;span>syntax &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;proto3&amp;#34;&lt;/span>;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#f92672">package&lt;/span> smartoven;&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#75715e">// Dienst OvenControl zum Steuern des Backofens
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">service&lt;/span> OvenControl {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#75715e">// Methode zum Backen eines Gegenstands
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">rpc&lt;/span> BakeItem (BakeRequest) &lt;span style="color:#66d9ef">returns&lt;/span> (BakeResponse) {}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">BakeRequest&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> item &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// Was soll gebacken werden?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> temperature &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// Temperatur in Grad Celsius
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int32&lt;/span> duration &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>; &lt;span style="color:#75715e">// Backdauer in Minuten
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span>&lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#a6e22e">BakeResponse&lt;/span> {&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> success &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// War der Backvorgang erfolgreich?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> &lt;span style="color:#66d9ef">message&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; &lt;span style="color:#75715e">// Zusätzliche Informationen oder Fehlermeldungen
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}&lt;span style="color:#960050;background-color:#1e0010">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Wir lesen das so: Wir haben einen Service &lt;code>OvenControl&lt;/code>, der eine Methode &lt;code>BakeItem&lt;/code> anbietet. Diese Methode erwartet ein &lt;code>BakeRequest&lt;/code>-Objekt und gibt ein &lt;code>BakeResponse&lt;/code>-Objekt zurück.&lt;/p>
&lt;p>Die Objekte &lt;code>BakeRequest&lt;/code> bestehen aus einem &lt;code>item&lt;/code> (z.B. &amp;ldquo;Pizza&amp;rdquo;), einer &lt;code>temperature&lt;/code> (z.B. 200) und einer &lt;code>duration&lt;/code> (z.B. 20).&lt;/p>
&lt;p>Das &lt;code>BakeResponse&lt;/code>-Objekt besteht aus einem &lt;code>success&lt;/code>-Flag und einer &lt;code>message&lt;/code>.&lt;/p>
&lt;p>Alle Datentypen sind in Protobuf statisch definiert und können auch nicht &amp;ldquo;falsch&amp;rdquo; übergeben werden. Das ist ein großer Vorteil gegenüber JSON oder XML. Auch gibt es weitere Datentypen, die hinzugefügt oder selbst definiert können, wie z.B. Timestamps, Enums oder Maps.&lt;/p>
&lt;p>Zumdem beherrscht GRPC auch Streaming, also das Senden und Empfangen von mehreren Nachrichten. Das ist besonders nützlich, wenn wir z.B. eine Chat-Anwendung entwickeln. Auch bidirectional Streaming ist möglich, also das gleichzeitige Senden und Empfangen von Nachrichten.&lt;/p>
&lt;h2 id="vorteile-für-teams">Vorteile für Teams&lt;/h2>
&lt;p>Stellen wir uns vor, dass dieses Projekt von mehreren Teams entwickelt wird. Jedes Team hat seine eigene Sprache und Technologie. Hier kommt mein Hautpargument für GRPC und Protobuf: Die Protobuf-Datei ist DIE Schnittstelle zwischen den Teams. Kein Rätselraten mehr, wie die Daten aussehen oder wie sie serialisiert werden. Die Datei stellt die &amp;ldquo;Wahrheit&amp;rdquo; und gleichzeitig Dokumentation für die Teams da.&lt;/p>
&lt;p>Aber da hört es nicht auf: Wäre es nicht wundervoll, wenn jemand für uns den Server schreiben würde? Oder den Client? Oder beides? GRPC bietet uns die Möglichkeit, automatisch Clients und Server in verschiedenen Sprachen zu generieren. Das spart uns eine Menge Zeit und Fehler.
Natürlich muss die Funktionalität noch implementiert werden, aber die Grundlagen sind schon mal gelegt - und das spart Zeit und Nerven.&lt;/p>
&lt;h2 id="reflection">Reflection&lt;/h2>
&lt;p>Aber wäre es nicht toll, wenn wir - gerade für Tests, nun einfach solche Protobuf/GRPC Nachrichten einfach senden könnten? Oder Empfangen? Gar kein Problem!
Wenn wir unseren Server mit Reflection starten (ist i.d.R. eine einfaches Flag), können wir mit GUI und cli clients einfach auf den Server zugreifen und Nachrichten senden. Ohne die Definition in die Hand nehmen zu müssen - die liefert der Server dem Client automatisch mit aus! Das ist ein mächtiges Werkzeug für die Entwicklung und das Testen.&lt;/p>
&lt;h2 id="die-probleme">Die Probleme&lt;/h2>
&lt;p>Aber nun kommt der Pferdefuß: Dadurch, dass GRPC UDP nutzt, ist es nicht so einfach, GRPC im Browser zu nutzen. Hier gibt es aber auch wieder viele Lösungen:&lt;/p>
&lt;ul>
&lt;li>REST Gateway: Ein Gateway, dass GRPC in REST umwandelt
Viele GRPC Server bieten die Möglichkeit, automatisch ein REST Gateway zu starten. Hierbei wird der GRPC Server um einen REST Server erweitert, der die GRPC Anfragen in REST Anfragen umwandelt. Das ist eine einfache Möglichkeit, GRPC in Browsern zu nutzen. Und eine wundervolle Art auf GRPC zu migrieren, ohne alte Clients kaputt zu machen. Aber hier &amp;ldquo;verlieren&amp;rdquo; wir die Vorteile von GRPC - zumindest im Browser. Ach: Und Streaming geht auch nicht.&lt;/li>
&lt;li>&lt;a href="https://github.com/grpc/grpc-web">grpc-web&lt;/a>: Eine Javascript Bibliothek, die es erlaubt mit GRPC zu kommunizieren - hier muss aber der Server auch entsprechend angepasst werden. Zudem gibt es nur Streaming von Server zu client. Schade.&lt;/li>
&lt;/ul>
&lt;h2 id="connect">Connect&lt;/h2>
&lt;p>Meine Lieblingslösung für das Problem ist aber Connect.
Connect ist eine GRPC kompatible Bibliothek, mit der ich meinen Server laufen lassen kann.
Ich merke keinerlei Unterschied, da es ein vollwertiger GRPC Server ist.&lt;/p>
&lt;p>Aber Connect hat eine Besonderheit: Connect auf dem Server ermöglicht es, dass sich Clients über Websockets verbinden können - von den Details bekomme ich aber wieder nichts mit - denn im Client verwende ich meine generierte connect Bibliothek, die sich um die Kommunikation kümmert. Und zwar MIT Streaming. Bidirektional. Wundervoll!&lt;/p>
&lt;h2 id="kurzfassung-tools">Kurzfassung Tools&lt;/h2>
&lt;p>Wir machen also folgendes:&lt;/p>
&lt;ol>
&lt;li>Wir definieren unsere Schnittstelle in Protobuf&lt;/li>
&lt;li>Wir generieren uns unsere Server mit der connect Bibliothek&lt;/li>
&lt;li>Wir generieren uns unsere Webclients mit der conenct Bilbiothek&lt;/li>
&lt;li>Wir generieren unsere anderen Clients (z.B. andere Server) mit der GRPC Bibliothek oder auch connect.&lt;/li>
&lt;/ol>
&lt;p>Nun können wir zwischen Webclient und Server kommunizieren - und das ganze auch noch sicher, da Websockets verschlüsselt sind. Und vor allem: Wir haben die Typsicherheit von Protobuf und die Effizienz von GRPC. Wundervoll!&lt;/p>
&lt;h2 id="fazit">Fazit&lt;/h2>
&lt;p>GRPC und Protobuf sind keine vorübergehenden Trends. Sie sind ausgereifte Technologien, die sich in der Praxis bewährt haben und kontinuierlich weiterentwickelt werden. Mit der Einführung von Connect wird die Verwendung von GRPC noch zugänglicher und vielseitiger.&lt;/p>
&lt;p>Als Entwickler schätze ich die Zuverlässigkeit, Geschwindigkeit und Einfachheit, die GRPC bietet. Es ermöglicht mir, robuste und effiziente APIs zu erstellen, die sowohl für meine Teammitglieder als auch für die Endbenutzer einen Mehrwert bieten.
Wenn Du noch nie mit GRPC gearbeitet haben, empfehle ich Ihnen, es in Ihrem nächsten Projekt auszuprobieren. Die klaren Schnittstellen, die Leistung und die Flexibilität sind es wert.&lt;/p></content></item></channel></rss>