<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Administration on Philipp Weißmann</title><link>https://philipp-weissmann.de/tags/administration/</link><description>Recent content in Administration on Philipp Weißmann</description><generator>Hugo -- gohugo.io</generator><language>de</language><lastBuildDate>Tue, 19 May 2015 19:15:13 +0000</lastBuildDate><atom:link href="https://philipp-weissmann.de/tags/administration/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Pakete mit fpm bauen</title><link>https://philipp-weissmann.de/linux-pakete-mit-fpm-bauen/</link><pubDate>Tue, 19 May 2015 19:15:13 +0000</pubDate><guid>https://philipp-weissmann.de/linux-pakete-mit-fpm-bauen/</guid><description>&lt;h1 id="software-installieren">Software installieren&lt;/h1>
&lt;p>Unter den meisten Linux Distributionen wird Software zumeist via Paketmanager&lt;br>
installiert.&lt;br>
Gerade in der Software-Entwicklung kommt es aber immer wieder dazu, dass&lt;br>
man selbstkompilierte oder selbstentwickelte Software installieren muss.&lt;/p>
&lt;p>Der übliche &amp;ldquo;Installationsmechanismus&amp;rdquo; via&lt;/p>
&lt;pre>&lt;code>./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install
&lt;/code>&lt;/pre>
&lt;p>führt jedoch dazu, dass die Software unversioniert installiert wird und eine&lt;br>
Deinstallation nur in mühseliger Handarbeit möglich ist.&lt;br>
Auch die Installation auf mehreren Rechner erfordert immer wieder den selben&lt;br>
Aufwand und eine Updatemöglichkeit gibt es ebenfalls nicht.&lt;/p></description><content>&lt;h1 id="software-installieren">Software installieren&lt;/h1>
&lt;p>Unter den meisten Linux Distributionen wird Software zumeist via Paketmanager&lt;br>
installiert.&lt;br>
Gerade in der Software-Entwicklung kommt es aber immer wieder dazu, dass&lt;br>
man selbstkompilierte oder selbstentwickelte Software installieren muss.&lt;/p>
&lt;p>Der übliche &amp;ldquo;Installationsmechanismus&amp;rdquo; via&lt;/p>
&lt;pre>&lt;code>./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install
&lt;/code>&lt;/pre>
&lt;p>führt jedoch dazu, dass die Software unversioniert installiert wird und eine&lt;br>
Deinstallation nur in mühseliger Handarbeit möglich ist.&lt;br>
Auch die Installation auf mehreren Rechner erfordert immer wieder den selben&lt;br>
Aufwand und eine Updatemöglichkeit gibt es ebenfalls nicht.&lt;/p>
&lt;h1 id="pakete">Pakete&lt;/h1>
&lt;p>Die optimale Lösung für unser Problem ist natürlich die Erstellung eines&lt;br>
eigenen Pakets:&lt;br>
Das Paket wird ein einziges Mal gebaut, kann jederzeit deinstalliert werden&lt;br>
und die Version des Pakets ist ebenfalls protokolliert, so dass später Updates&lt;br>
möglich sind.&lt;/p>
&lt;p>Das Problem daran ist, dass das Entwickeln von Paketen recht Aufwändig ist.&lt;br>
Eine Abhilfe schafft hierbei das&lt;br>
Werkzeug &lt;a href="https://github.com/jordansissel/fpm">fpm&lt;/a>.&lt;/p>
&lt;h1 id="installation">Installation&lt;/h1>
&lt;p>Zunächst stellen wir sicher, dass auf unserem Rechner das Paket &lt;code>ruby-dev&lt;/code>&lt;br>
installiert ist:&lt;/p>
&lt;p>Bei auf Debian basierenden Systemen (z.B. Ubuntu):&lt;/p>
&lt;pre>&lt;code>sudo apt-get install install ruby-dev
&lt;/code>&lt;/pre>
&lt;p>Bei auf RedHat basierenden Systemen (z.B. CentOS):&lt;/p>
&lt;pre>&lt;code>sudo yum install fpm
&lt;/code>&lt;/pre>
&lt;p>Nun können wir mit dem Ruby Paketinstaller &lt;code>gem&lt;/code> das Programm installieren:&lt;/p>
&lt;pre>&lt;code>gem install fpm
&lt;/code>&lt;/pre>
&lt;p>Nun sollte das Programm &lt;code>fpm&lt;/code> auf der Kommandozeile zur Verfügung stehen.&lt;/p>
&lt;h1 id="paket-bauen">Paket bauen&lt;/h1>
&lt;p>Wir haben nun unsere Software wie zuvor und bauen diese - jedoch mit einem&lt;br>
Präfix, z.B.:&lt;/p>
&lt;pre>&lt;code>mkdir /tmp/place_to_install
./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install DESTDIR=/tmp/place_to_install
&lt;/code>&lt;/pre>
&lt;p>Wenn wir nun an den Ort &lt;code>/tmp/place_to_install&lt;/code> schauen, sehen wir dort die&lt;br>
installierten Daten. Diese sollen nun in unser Paket kommen.&lt;br>
Diese bauen wir mit:&lt;/p>
&lt;pre>&lt;code>fpm -s dir -t rpm -n myprogram -v 0.1.2 -C /tmp/place_to_install bin lib
&lt;/code>&lt;/pre>
&lt;p>Hierbei stehen die Parameter für:&lt;/p>
&lt;ul>
&lt;li>&lt;code>-s dir&lt;/code>: Das Paket wird aus einem Verzeichnis gebaut (andere Möglichkeiten u.a. Python Module, rpm Dateien usw.)&lt;/li>
&lt;li>&lt;code>-t rpm&lt;/code>: Es soll ein rpm-Paket gebaut werden. Auch deb-Pakete sind möglich&lt;/li>
&lt;li>&lt;code>-n myprogram&lt;/code>: Der Name des Pakets&lt;/li>
&lt;li>&lt;code>-v 0.1.2&lt;/code>: Die Version des Pakets&lt;/li>
&lt;li>&lt;code>-C /tmp/place_to_install&lt;/code>: Das Verzeichnis, in dem sich die Dateien befinden&lt;/li>
&lt;li>&lt;code>bin lib&lt;/code>: Die Dateien/Verzeichnisse in dem Verzeichnis, welche auch wirklich im Zielsystem installiert werden sollen&lt;/li>
&lt;/ul>
&lt;p>Nach kurzer Wartezeit purzelt aus dem Werkzeugs ein installierbares Paket heraus.&lt;/p>
&lt;h1 id="fazit">Fazit&lt;/h1>
&lt;p>Mit fpm lassen sich bequem, schnell und einfach Pakete bauen.&lt;br>
Natürlich berücksichtigt das hier erstellte Paket keinerlei Abhängigkeiten und&lt;br>
es werden auch nicht alle Möglichkeiten und Funktionen des Paketmanagements genutzt, aber&lt;br>
in der Praxis erleichtert dies die Installation von Software - gerade in Teams&lt;br>
ungemein.&lt;/p>
&lt;p>Jetzt nur noch ein Repository-Server aufgesetzt - und schon hat man im Team&lt;br>
eine komfortablen Weg Software bereit zu stellen.&lt;/p></content></item><item><title>Myrepos: Alle meine Repositories</title><link>https://philipp-weissmann.de/myrepos-alle-meine-repositories/</link><pubDate>Sun, 17 May 2015 13:15:05 +0000</pubDate><guid>https://philipp-weissmann.de/myrepos-alle-meine-repositories/</guid><description>&lt;h1 id="repository-zentrale">Repository-Zentrale&lt;/h1>
&lt;p>Dank VCSH habe ich all meine Dotfiles hübsch in Git-Repositories verpackt.&lt;br>
Das Einbinden eines einzelnen Repositories geht nun zwar schnell von der Hand,&lt;br>
aber wenn nun für &lt;code>vim&lt;/code> und &lt;code>mutt&lt;/code> und &lt;code>emacs&lt;/code> und und und &amp;hellip; lauter&lt;br>
Repositories vorliegen wird es unbequem.&lt;br>
Auch das updaten (&lt;code>pull&lt;/code>) jedes einzelnen Repos ist sehr mühselig und damit&lt;br>
fehleranfällig.&lt;/p>
&lt;p>Abhilfe schafft hier &lt;a href="https://myrepos.branchable.com/">myrepos&lt;/a> (kurz &lt;code>mr&lt;/code>),&lt;br>
dass es erlaubt Aktionen auf mehreren Repositories auszuführen.&lt;/p></description><content>&lt;h1 id="repository-zentrale">Repository-Zentrale&lt;/h1>
&lt;p>Dank VCSH habe ich all meine Dotfiles hübsch in Git-Repositories verpackt.&lt;br>
Das Einbinden eines einzelnen Repositories geht nun zwar schnell von der Hand,&lt;br>
aber wenn nun für &lt;code>vim&lt;/code> und &lt;code>mutt&lt;/code> und &lt;code>emacs&lt;/code> und und und &amp;hellip; lauter&lt;br>
Repositories vorliegen wird es unbequem.&lt;br>
Auch das updaten (&lt;code>pull&lt;/code>) jedes einzelnen Repos ist sehr mühselig und damit&lt;br>
fehleranfällig.&lt;/p>
&lt;p>Abhilfe schafft hier &lt;a href="https://myrepos.branchable.com/">myrepos&lt;/a> (kurz &lt;code>mr&lt;/code>),&lt;br>
dass es erlaubt Aktionen auf mehreren Repositories auszuführen.&lt;/p>
&lt;h1 id="installation">Installation&lt;/h1>
&lt;p>Wir installieren uns das Paket &lt;code>myrepos&lt;/code> via &lt;code>apt-get&lt;/code> oder &lt;code>yaourt&lt;/code>&lt;/p>
&lt;p>Installation unter Debian/Ubuntu:&lt;/p>
&lt;pre>&lt;code>sudo apt-get install myrepos
&lt;/code>&lt;/pre>
&lt;p>oder unter Arch Linux&lt;/p>
&lt;pre>&lt;code>yaourt -S myrepos
&lt;/code>&lt;/pre>
&lt;h1 id="basis-konfiguration">Basis-Konfiguration&lt;/h1>
&lt;p>Wir legen eine Konfigurationsdatei mit dem Namen &lt;code>~/.mrconfig&lt;/code> an mit folgendem&lt;br>
Inhalt:&lt;/p>
&lt;pre>&lt;code>[DEFAULT]
git_gc = git gc &amp;quot;$@&amp;quot;
jobs = 1
include = cat ~/.config/mr/config.d/*
&lt;/code>&lt;/pre>
&lt;p>Wenn nach allen Schritten die Konfiguration zuverlässig installiert können wir&lt;br>
die Anzahl der parallelen Jobs auf z.B. 4 erhöhen.&lt;/p>
&lt;p>Nun legen wir folgende Verzeichnisse an:&lt;/p>
&lt;pre>&lt;code>mkdir -p ~/.config/mr/config.d
mkdir ~/.config/mr/available.d
&lt;/code>&lt;/pre>
&lt;p>In das Verzeichnis &lt;code>available.d&lt;/code> legen wir alle Konfigurationsdateien ab.&lt;/p>
&lt;p>Eine solche Konfigurationsdatei enthält den Ort Zielort des Repositories&lt;br>
und auch die Anweisung, woher die Quelle kommt.&lt;/p>
&lt;p>Die Datei für eine &lt;code>vim&lt;/code>-VCSH-Konfiguration könnte z.B. so aussehen:&lt;/p>
&lt;p>Dateiname: &lt;code>vim.vcsh&lt;/code>&lt;/p>
&lt;pre>&lt;code>[$HOME/.config/vcsh/repo.d/vim.git]
checkout = vcsh clone git@MEINGITSERVER:vim vim
&lt;/code>&lt;/pre>
&lt;p>Dabei kann myrepos vcsh oder direkt git oder auch subversion (u.v.m.) nutzen.&lt;/p>
&lt;p>Nun linke (&lt;code>ln -s&lt;/code>) ich noch alle die Konfigurationsdateien nach &lt;code>available.d&lt;/code>,&lt;br>
die auch wirklich auf all meinen Systemen nutzen möchte.&lt;/p>
&lt;p>Mit dem Aufruf&lt;/p>
&lt;pre>&lt;code>mr up
&lt;/code>&lt;/pre>
&lt;p>Aktualisiere (z.B. bei git: pull) ich nun alle Repositories, die ich via&lt;br>
myrepos verwalte. Somit kann ich beim Wechsel von Rechnern einfach meine&lt;br>
Konfiguration aktualisieren.&lt;/p>
&lt;p>Auch pushen von allen Repositories ist möglich:&lt;/p>
&lt;pre>&lt;code>mr push
&lt;/code>&lt;/pre>
&lt;p>usw.&lt;/p>
&lt;h1 id="myrepos-in-vcsh">Myrepos in VCSH&lt;/h1>
&lt;p>Auch die Konfiguration von myrepos selbst verwalte ich mit vcsh (und&lt;br>
wiederum mit Datei-Eintrag in myrepos), so dass sich auch beim Hinzukommen&lt;br>
von neuen Repositories ich diese auf meinen Geräten erhalte.&lt;/p>
&lt;h1 id="neuer-rechner---einfacher-schritt">Neuer Rechner - einfacher Schritt&lt;/h1>
&lt;p>Bei einem neuen Rechner sind nun extrem wenige Schritte notwendig:&lt;/p>
&lt;ol>
&lt;li>Installieren von vcsh und myrepos (gibt es zumeist im Paketmanager)&lt;/li>
&lt;li>Klonen des myrepos vcsh repositories (d.h. &lt;code>vcsh clone git@MEINGITSERVER:mr mr&lt;/code>)&lt;/li>
&lt;li>Klonen aller weiteren Repos via &lt;code>mr up&lt;/code>&lt;/li>
&lt;/ol>
&lt;h1 id="sonderfälle">Sonderfälle&lt;/h1>
&lt;p>Auch einfache Programme (z.B. &lt;a href="https://rg3.github.io/youtube-dl/">youtube-dl&lt;/a>)&lt;br>
installiere (und update) ich via myrepos: Hierzu leg ich ich wieder eine&lt;br>
Konfigurationsdatei an (z.B. &lt;code>youtube-dl.git&lt;/code>) mit folgendem Inhalt:&lt;/p>
&lt;pre>&lt;code>[$HOME/.local/opt/youtube-dl.git]
checkout = git clone https://github.com/rg3/youtube-dl.git $HOME/.local/opt/youtube-dl.git
push = echo &amp;quot;No pushing to public repo&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Der &lt;code>push&lt;/code> Befehl wird hier explizit überschrieben und gibt bei &lt;code>mr push&lt;/code> einfach die&lt;br>
Nachricht aus, dass ich in dieses Repository nicht pushen möchte.&lt;/p>
&lt;h1 id="fazit">Fazit&lt;/h1>
&lt;p>Myrepos ermöglicht das einfache und bequeme Verwalten und Nutzen von vielen&lt;br>
Repositories. Gerade das Updaten oder initiale Klonen wird damit deutlich&lt;br>
bequemer. Insbesondere im Zusammenspiel mit VCSH wird eine extrem komfortable&lt;br>
Verwaltung der eigenen Dotfiles (und mehr) möglich.&lt;/p></content></item><item><title>Konfigurationsdateien verwalten mit VCSH</title><link>https://philipp-weissmann.de/konfigurationsdateien-verwalten-mit-vcsh/</link><pubDate>Sun, 19 Apr 2015 17:32:15 +0000</pubDate><guid>https://philipp-weissmann.de/konfigurationsdateien-verwalten-mit-vcsh/</guid><description>&lt;h1 id="einstellungen">Einstellungen&lt;/h1>
&lt;p>Was ist der erste Schritt bei der Benutzung eines Autos, einer Stereoanlage oder eines Schreibtischstuhls?&lt;br>
Die Einstellungen!&lt;br>
Natürlich will man gut aus dem Fahrzeug sehen können, der Lieblings-Musik lauschen und bequem sitzen.&lt;/p>
&lt;p>Doch auch Software hat Einstellungen:&lt;/p>
&lt;ul>
&lt;li>Welchen Editor setze ich als Standard?&lt;/li>
&lt;li>Welche Shell-Erweiterungen lade ich in &lt;code>oh-my-zsh&lt;/code>?&lt;/li>
&lt;li>Welches &lt;code>color-theme&lt;/code> lade ich in vim?&lt;/li>
&lt;li>Welche Accounts habe ich in &lt;code>mutt&lt;/code>?&lt;/li>
&lt;/ul>
&lt;p>Praktischerweise liegen all diese Einstellungen in Dateien (sogenannten &amp;ldquo;Dotfiles&amp;rdquo;), welche sich einfach von A nach B kopieren lassen.&lt;br>
Da ich jedoch regelmässig auf unterschiedlichen Rechnern arbeite, möchte ich diese aktuell halten.&lt;/p></description><content>&lt;h1 id="einstellungen">Einstellungen&lt;/h1>
&lt;p>Was ist der erste Schritt bei der Benutzung eines Autos, einer Stereoanlage oder eines Schreibtischstuhls?&lt;br>
Die Einstellungen!&lt;br>
Natürlich will man gut aus dem Fahrzeug sehen können, der Lieblings-Musik lauschen und bequem sitzen.&lt;/p>
&lt;p>Doch auch Software hat Einstellungen:&lt;/p>
&lt;ul>
&lt;li>Welchen Editor setze ich als Standard?&lt;/li>
&lt;li>Welche Shell-Erweiterungen lade ich in &lt;code>oh-my-zsh&lt;/code>?&lt;/li>
&lt;li>Welches &lt;code>color-theme&lt;/code> lade ich in vim?&lt;/li>
&lt;li>Welche Accounts habe ich in &lt;code>mutt&lt;/code>?&lt;/li>
&lt;/ul>
&lt;p>Praktischerweise liegen all diese Einstellungen in Dateien (sogenannten &amp;ldquo;Dotfiles&amp;rdquo;), welche sich einfach von A nach B kopieren lassen.&lt;br>
Da ich jedoch regelmässig auf unterschiedlichen Rechnern arbeite, möchte ich diese aktuell halten.&lt;/p>
&lt;h1 id="dropbox">Dropbox&lt;/h1>
&lt;p>Mein erster Ansatz war es, alle Dateien in einen zentralen Dropbox Ordner zu verschieben und Links zu erstellen nach folgendem Schema&lt;/p>
&lt;pre>&lt;code>~/.vimrc -&amp;gt; ~/Dropbox/config/vimrc
&lt;/code>&lt;/pre>
&lt;p>Meine &lt;code>.vimrc&lt;/code> wurde durch den Dropbox-Dienst nun auf allen Rechnern synchronisiert und immer aktuell.&lt;br>
Richtete ich einen neuen Rechner ein, so musste ich &amp;ldquo;nur&amp;rdquo; Dropbox und den Link erstellen.&lt;/p>
&lt;p>Dieser Ansatz hat jedoch einige Nachteile:&lt;/p>
&lt;ol>
&lt;li>Ich bin von der Verfügbarkeit von Dropbox abhängig (ist ok für mich)&lt;/li>
&lt;li>Ich muss auf allen Rechnern Dropbox installieren (ist auch noch so ok)&lt;/li>
&lt;li>Ich muss alle Dateien händisch verlinken (nicht ok!)&lt;/li>
&lt;li>Die Änderungen sind nicht dokumentiert bzw. haben keine definierten Zwischenstände (nicht ok!)&lt;/li>
&lt;li>Alle Änderungen werden sofort bei allen Systemen aktualisiert (außer ich stoppe Dropbox)&lt;/li>
&lt;/ol>
&lt;h1 id="vcsh">VCSH&lt;/h1>
&lt;p>Ich wünschte mir ein System, welches die Versionierung der Konfigurationsdaten übernimmt und bin dabei auf VCHS gestoßen.&lt;/p>
&lt;p>Das schöne an VCSH: Es baut einfach auf git auf und bietet somit einerseits ein vertrautes Interface. Zudem kann ich meine Konfigurationsdateien nun einfach in ein zentrales Repository (z.B. auf Github oder auf einem eigenen Server) ablegen.&lt;/p>
&lt;h2 id="installieren">Installieren&lt;/h2>
&lt;p>Installieren erfolgt aus dem Repository, Debian/Ubuntu also per&lt;/p>
&lt;pre>&lt;code>apt-get install vcsh
&lt;/code>&lt;/pre>
&lt;p>oder bei Arch Linux via aur (hier mit yaourt)&lt;/p>
&lt;pre>&lt;code>yaourt -S vcsh
&lt;/code>&lt;/pre>
&lt;h2 id="anlegen">Anlegen&lt;/h2>
&lt;p>Ich empfehle pro Werkzeug (z.B. emacs, mutt, &amp;hellip;) ein eigenes Repository anzulegen um die Übersicht zu behalten.&lt;br>
Die Syntax hierbei entspricht der von git, jedoch mit Namen des Werkzeugs vorangestellt, also &lt;code>vcsh WERKZEUG GIT-BEFEHL&lt;/code> (Ausnahme: &lt;code>init&lt;/code>-Befehl)&lt;/p>
&lt;p>Wir initialisieren uns erstmal ein Repository für unsere Vim-Einstellungen&amp;hellip;&lt;/p>
&lt;pre>&lt;code>vcsh init vim
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; fügen die Datei(en) hinzu, die wir verwalten wollen &amp;hellip;&lt;/p>
&lt;pre>&lt;code>vcsh vim add ~/.vimrc
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; machen unseren ersten commit &amp;hellip;&lt;/p>
&lt;pre>&lt;code>vcsh vim commit -m &amp;quot;Mein erster Vim-commit&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; und pushen diesen auf unseren Git-Server (z.B. Github)&lt;/p>
&lt;pre>&lt;code>vcsh vim remote add git@MEINGITSERVER:vim.git
vcsh vim push -u origin master
&lt;/code>&lt;/pre>
&lt;h2 id="klonen">Klonen&lt;/h2>
&lt;p>Auf einem neuen Rechner können wir uns die Konfiguration einfach holen:&lt;/p>
&lt;pre>&lt;code>vcsh clone git@MEINGISERVER:vim.git
&lt;/code>&lt;/pre>
&lt;h2 id="gitignore">.gitignore&lt;/h2>
&lt;p>Da sich unsere Konfigurationsdateien im Home-Verzeichnis des Users befinden, hat VCSH (bzw. git) keine Chance zu wissen welche Dateien definitiv zu dem Projekt gehören und welche nicht.&lt;br>
Also schaffen wir mit einer .gitignore-Datei Abhilfe: Alle Dateien und Verzeichnisse sollen ignoriert werden, außer den Projektdateien/Ordnern.&lt;br>
Diese erstellen wir automatisch via&lt;/p>
&lt;pre>&lt;code>vcsh write-gitignore vim
&lt;/code>&lt;/pre>
&lt;p>Wie fügen die ignore-Datei selbst auch dem Projekt hinzu&amp;hellip;&lt;/p>
&lt;pre>&lt;code>vcsh vim add -f ~/.gitignore.d/vim
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; und schreiben die Datei erneut.&lt;/p>
&lt;pre>&lt;code>vcsh write-gitignore vim
&lt;/code>&lt;/pre>
&lt;p>Nun kontrollieren wir die Datei &lt;code>~/.gitignore.d/vim&lt;/code> ob sie nicht Dateien ignoriert, welche wir versionieren wollen;&lt;br>
Wenn nicht: Ab damit ins Repository!&lt;/p>
&lt;pre>&lt;code>vcsh vim add ~/.gitignore.d/vim
&lt;/code>&lt;/pre>
&lt;p>Alle weiteren Aktionen können wir nun in gewohnter git-manier (commit push pull) erledigen.&lt;/p>
&lt;h1 id="fazit">Fazit&lt;/h1>
&lt;p>VCSH erlaubt es bequem Dotfiles zu organisieren und diese versioniert abzulegen.&lt;br>
Im Alltag hilft mir es enorm meine Konfigurationsdateien auf einem Stand zu halten und Änderungen dokumentiert.&lt;/p>
&lt;p>Ergänzend zu VCSH bietet sich die Benutzung von &lt;code>myrepos&lt;/code> ab um mehrere Repositories gleichzeitig zu verwalten.&lt;/p></content></item></channel></rss>