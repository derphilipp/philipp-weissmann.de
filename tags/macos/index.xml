<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>macOS on Philipp Weißmann</title><link>https://philipp-weissmann.de/tags/macos/</link><description>Recent content in macOS on Philipp Weißmann</description><generator>Hugo -- gohugo.io</generator><language>de-de</language><lastBuildDate>Sat, 14 Sep 2019 08:11:33 +0000</lastBuildDate><atom:link href="https://philipp-weissmann.de/tags/macos/index.xml" rel="self" type="application/rss+xml"/><item><title>Umbenennen mit dem Lieblingseditor</title><link>https://philipp-weissmann.de/umbenennen-mit-dem-lieblingseditor/</link><pubDate>Sat, 14 Sep 2019 08:11:33 +0000</pubDate><guid>https://philipp-weissmann.de/umbenennen-mit-dem-lieblingseditor/</guid><description>Dateien umbenennen ist oft mühsam. Wenn man ein Extra-Werkzeug benutzt, muss man es erst lernen. Das schreiben eines extra Skriptes kann aber oft zu aufwendig sein. Es wäre doch schön, wenn man direkt im Lieblingseditor die Dateinamen verändern könnte.
Hier kommt die Werkzeugsammlung renameutils zum Einsatz.
Installation Installiert wird das ganze aus den üblichen Paketmanagern, also z.B.
brew install renameutils # macOS / Linuxbrew pacman-S renameutils # Arch based sudo apt install renameutils # Debian based Benutzung Nun gibt es die Befehle: qmv und qcp, mit denen Dateien umbenannt, bzw.</description><content>&lt;p>Dateien umbenennen ist oft mühsam.
Wenn man ein Extra-Werkzeug benutzt, muss man es erst lernen.
Das schreiben eines extra Skriptes kann aber oft zu aufwendig sein.
Es wäre doch schön, wenn man direkt im Lieblingseditor die Dateinamen verändern könnte.&lt;/p>
&lt;p>Hier kommt die Werkzeugsammlung &lt;code>renameutils&lt;/code> zum Einsatz.&lt;/p>
&lt;h2 id="installation">Installation&lt;/h2>
&lt;p>Installiert wird das ganze aus den üblichen Paketmanagern, also z.B.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>brew install renameutils &lt;span style="color:#75715e"># macOS / Linuxbrew&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>pacman-S renameutils &lt;span style="color:#75715e"># Arch based&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt install renameutils &lt;span style="color:#75715e"># Debian based&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="benutzung">Benutzung&lt;/h2>
&lt;p>Nun gibt es die Befehle: &lt;code>qmv&lt;/code> und &lt;code>qcp&lt;/code>, mit denen Dateien umbenannt, bzw. kopiert werden können.&lt;/p>
&lt;p>Beispiel:&lt;/p>
&lt;pre>&lt;code>ls *.txt
&lt;/code>&lt;/pre>
&lt;p>Ausgabe:&lt;/p>
&lt;pre>&lt;code>Kopie von hallo.txt
Kopie von gutentag.txt
Kopie von abrechnung.txt
&lt;/code>&lt;/pre>
&lt;p>Nun verwenden wir unser neues Werkzeug:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>qmv *.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Nun öffnet sich unser eingestellter Editor mit einer Dateiliste und wir können die Datei-Umbenennungen direkt im Editor vornehmen.&lt;/p>
&lt;h2 id="fazit">Fazit&lt;/h2>
&lt;p>Das Verwenden von Shell-Kommandos zum Umbennen ist oft schnell.
So geht das Umbenennen aller &lt;code>.txt&lt;/code> Dateien in &lt;code>.md&lt;/code> schnell von der Hand.&lt;/p>
&lt;p>Für komplexe Fälle können wir &lt;code>qmv&lt;/code> verwenden. Damit können wir unseren vertrauten Editor und alle darin vorhandenen Funktionen nutzen.
Insbesondere, wenn wir keine einfachen Regeln zum Umbenennen formulieren können, helfen uns die &lt;code>renameutils&lt;/code> hier stark weiter.&lt;/p>
&lt;p>So ist bei mir der Alias&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>alias ren&lt;span style="color:#f92672">=&lt;/span>qmv --format&lt;span style="color:#f92672">=&lt;/span>destination-only
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>fest in meine Werkzeugkiste eingezogen.&lt;/p></content></item><item><title>Simples deployment via git</title><link>https://philipp-weissmann.de/simples-deployment-via-git/</link><pubDate>Tue, 16 Apr 2019 19:59:37 +0000</pubDate><guid>https://philipp-weissmann.de/simples-deployment-via-git/</guid><description>Das Problem Egal ob Homepage, Konfigurationsdateien oder Programmcode: Für praktisch alle Projekte verwendet man heute git.
Möchte man jedoch Versionen automatisch ausrollen (z.B. statische HTML Dateien einer Webseite), benötigt man einige Skripte oder einen Build-Dienst wie z.B. Gitlab-CI, Jenkins oder CircleCI.
Oftmals reicht es jedoch die Daten auf das Zielsystem zu kopieren. Aber auch das geht mit git:
Ausgangssituation Wie haben einen Server (für die Homepage), einen Laptop (für die Entwicklungsarbeit), sowie ein Git-Projekt (z.</description><content>&lt;h1 id="das-problem">Das Problem&lt;/h1>
&lt;p>Egal ob Homepage, Konfigurationsdateien oder Programmcode: Für praktisch alle Projekte verwendet man heute &lt;a href="https://de.wikipedia.org/wiki/Git">git&lt;/a>.&lt;/p>
&lt;p>Möchte man jedoch Versionen automatisch ausrollen (z.B. statische HTML Dateien einer Webseite), benötigt man einige Skripte oder einen Build-Dienst wie z.B. Gitlab-CI, Jenkins oder CircleCI.&lt;/p>
&lt;p>Oftmals reicht es jedoch die Daten auf das Zielsystem zu kopieren. Aber auch das geht mit git:&lt;/p>
&lt;h1 id="ausgangssituation">Ausgangssituation&lt;/h1>
&lt;p>Wie haben einen Server (für die Homepage), einen Laptop (für die Entwicklungsarbeit), sowie ein Git-Projekt (z.B. bei Github).
Auf Github befindet sich unser Projekt.
Auf Laptop wie auch auf dem Server haben wir uns mit &lt;code>git clone&lt;/code> das Projekt eingerichtet.&lt;/p>
&lt;h1 id="vorgehen">Vorgehen&lt;/h1>
&lt;p>Das Projekt auf dem Server soll beim Empfangen neuer Dateien diese auch in das &amp;ldquo;Working Directory&amp;rdquo; schreiben. Dies aktivieren wir mit:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># auf Server, im Projektverzeichnis&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git config receive.denyCurrentBranch updateInstead
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Nun müssen wir unserem Projekt auf dem Laptop das neue Ziel beibringen:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># auf Laptop, im Projektverzeichnis&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git remote add deploy benutzer@servername:/pfad/zu/projektordner/auf/server
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># jetzt noch sagen: schiebe den lokalen branch _master_ auf den server (nur 1 mal notwendig)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push --set-upstream deploy master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Unsere Änderungen können wir weiterhin zu Github schieben:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git push origin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Aber nun auch neu: Auf dem Server direkt ausrollen:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git push deploy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Es ist sogar möglich mittels &lt;code>push-url&lt;/code> mehrere Ziele auf einmal zu definieren.&lt;/p>
&lt;h1 id="fazit">Fazit&lt;/h1>
&lt;p>Natürlich ersetzt unser kleiner Workflow keinen Build-Server oder ausgetüftelte Deployment Prozesse. Aber für Kleinst-Projekte kann das vorgehen mit &lt;code>updateInstead&lt;/code> sehr praktisch sein.&lt;/p>
&lt;p>&lt;strong>Aber Achtung&lt;/strong>: Verwenden wir diese Möglichkeit um Webseiten zu versionieren: Nicht vergessen, den &lt;code>.git&lt;/code> Ordner nicht auszuliefern.&lt;/p></content></item><item><title>Dateien finden mit fd</title><link>https://philipp-weissmann.de/dateien-finden-mit-fd/</link><pubDate>Thu, 11 Apr 2019 16:00:10 +0000</pubDate><guid>https://philipp-weissmann.de/dateien-finden-mit-fd/</guid><description>Das Tool find ist ein praktisches Programm und Dateien und Ordner zu finden. Find kann aber auch komplexere Aktionen wie z.B. mehrere Dateien konvertieren. Leider ist es jedoch nicht allzu einsteigerfreundlich.
Hier kommt fd ins Spiel:
Das Open-Source Programm erledigt nahezu alle Aufgaben von find, ist aber einfacher zu bedienen.
Beispiel1 Finde alle Dateien mit der Zeichenfolge schuh im Namen:
find:
find . -iname &amp;#39;*schuh*&amp;#39; fd:
fd schuh Beispiel 2 Finde alle .</description><content>&lt;p>Das Tool &lt;a href="https://www.gnu.org/software/findutils/manual/html_mono/find.html">find&lt;/a> ist ein praktisches Programm und Dateien und Ordner zu finden.
Find kann aber auch komplexere Aktionen wie z.B. mehrere Dateien konvertieren. Leider ist es jedoch nicht allzu einsteigerfreundlich.&lt;/p>
&lt;p>Hier kommt &lt;a href="https://github.com/sharkdp/fd">fd&lt;/a> ins Spiel:&lt;/p>
&lt;p>Das Open-Source Programm erledigt nahezu alle Aufgaben von &lt;code>find&lt;/code>, ist aber einfacher zu bedienen.&lt;/p>
&lt;h1 id="beispiel1">Beispiel1&lt;/h1>
&lt;p>Finde alle Dateien mit der Zeichenfolge &lt;em>schuh&lt;/em> im Namen:&lt;/p>
&lt;p>find:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>find . -iname &lt;span style="color:#e6db74">&amp;#39;*schuh*&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>fd:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>fd schuh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="beispiel-2">Beispiel 2&lt;/h1>
&lt;p>Finde alle .jpg Dateien:&lt;/p>
&lt;p>find:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>find . -iname &lt;span style="color:#e6db74">&amp;#39;*.jpg&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>fd:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>fd -e jpg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="beispiel-3">Beispiel 3&lt;/h1>
&lt;p>Finde alle .png Dateien und konvertiere diese in .jpg Dateien:&lt;/p>
&lt;p>find:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Konvertiert eine nach der anderen Datei&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find ./ -name &lt;span style="color:#e6db74">&amp;#39;*.png&amp;#39;&lt;/span> -exec bash -c &lt;span style="color:#e6db74">&amp;#39;convert $0 ${0/png/jpg}&amp;#39;&lt;/span> &lt;span style="color:#f92672">{}&lt;/span> &lt;span style="color:#ae81ff">\;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>fd:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Konvertiert parallel mehrere Dateien auf einmal&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fd -e png -x convert &lt;span style="color:#f92672">{}&lt;/span> &lt;span style="color:#f92672">{&lt;/span>.&lt;span style="color:#f92672">}&lt;/span>.jpg
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="fazit">Fazit:&lt;/h1>
&lt;p>Wer &lt;code>find&lt;/code> in- und auswendig beherrscht hat keinen Zwang zu wechseln. Der bequeme Syntax von &lt;code>fd&lt;/code> macht das Leben jedoch leichter. Die Möglichkeit parallel mehrere Dateien zu verarbeiten ist ungemein praktisch. Daher ist &lt;code>fd&lt;/code> für jeden Kommandozeilen-Fan absolut empfehlenswert.&lt;/p></content></item><item><title>SD Karte beschreiben mit „flash“</title><link>https://philipp-weissmann.de/sd-karte-beschreiben-mit-flash/</link><pubDate>Tue, 29 Nov 2016 08:30:27 +0000</pubDate><guid>https://philipp-weissmann.de/sd-karte-beschreiben-mit-flash/</guid><description>Um einen Raspberry Pi in Betrieb zu nehmen, ist es notwendig eine SD Karte mit einem Betriebssystem zu beschreiben. Dabei ist es in der Regel nicht mit einem einfachen Datei kopieren getan.
Unter Windows bietet sich Win32 Disk Imager an, unter macOS das Tool ApplePi Baker und unter Linux nutzt man einfach dd.
Nun wünscht man sich bei häufiger Nutzung ein einfaches Kommandozeilentool, dass diese Aufgabe komfortabel übernimmt.
Genau das erledigt das Tool flash.</description><content>&lt;p>Um einen Raspberry Pi in Betrieb zu nehmen, ist es notwendig eine SD Karte mit einem Betriebssystem zu beschreiben.
Dabei ist es in der Regel nicht mit einem einfachen Datei kopieren getan.&lt;/p>
&lt;p>Unter Windows bietet sich &lt;a href="https://sourceforge.net/projects/win32diskimager/">Win32 Disk Imager&lt;/a> an,
unter macOS das Tool &lt;a href="http://www.tweaking4all.com/software/macosx-software/macosx-apple-pi-baker/">ApplePi Baker&lt;/a> und unter Linux nutzt man einfach &lt;code>dd&lt;/code>.&lt;/p>
&lt;p>Nun wünscht man sich bei häufiger Nutzung ein einfaches Kommandozeilentool, dass diese Aufgabe komfortabel übernimmt.&lt;/p>
&lt;p>Genau das erledigt das Tool &lt;a href="https://github.com/hypriot/flash">flash&lt;/a>.
Das in &lt;a href="https://de.wikipedia.org/wiki/Bash_(Shell)">bash&lt;/a> geschrieben Werkzeug ist schnell installiert:&lt;/p>
&lt;pre>&lt;code>curl -O https://raw.githubusercontent.com/hypriot/flash/master/$(uname -s)/flash
chmod +x flash
sudo mv flash /usr/local/bin/flash
&lt;/code>&lt;/pre>
&lt;p>Wie in der &lt;a href="https://github.com/hypriot/flash">Installationsanleitung auf Github&lt;/a> zu sehen, sind noch optionale Abhängigkeiten auf einige Tools zu installieren (u.a. &lt;code>curl&lt;/code>, &lt;code>pv&lt;/code>, &lt;code>unzip&lt;/code>).
Nach erfolgreicher Installation durch den Paketmanager des Vertrauens, können Raspberry Images geschrieben werden:&lt;/p>
&lt;pre>&lt;code>flash jessie-light.zip
&lt;/code>&lt;/pre>
&lt;p>Dabei übernimmt &lt;code>flash&lt;/code> das entpacken (bzw. Download) der Datei und fordert den Benutzer anschließend auf, die SD Karte einzulegen. Nach Identifizieren des Speichermediums braucht man lediglich selbiges zu bestätigen und der Schreibeprozess beginnt.&lt;/p>
&lt;p>Zum Abschluss des Ganzen werden auch alle Dateisystem ausgehängt und die Speicherkarte kann in den Raspberry Pi wandern.&lt;/p>
&lt;p>Für mich ist &lt;code>flash&lt;/code> &lt;em>das&lt;/em> Werkzeug zum Schreiben von SD Karten geworden.
Minimalistisch, komfortabel und einfach zu handhaben erleichtert mit das kleine Helferlein den Alltag.&lt;/p></content></item><item><title>Homebrew Cask mit Ansible</title><link>https://philipp-weissmann.de/homebrew-cask-mit-ansible/</link><pubDate>Fri, 03 Jun 2016 06:52:45 +0000</pubDate><guid>https://philipp-weissmann.de/homebrew-cask-mit-ansible/</guid><description>&lt;p>Paketmanager auf modernen Betriebssystemen sind ein wahrer Segen: Programme
können einfach installiert, auf den aktuellsten Stand gebracht und restlos
deinstalliert werden.
Auch können mit einfachen Mitteln definierte Installationen bzw.
Systemkonfigurationen erstellt werden.&lt;/p></description><content>&lt;p>Paketmanager auf modernen Betriebssystemen sind ein wahrer Segen: Programme
können einfach installiert, auf den aktuellsten Stand gebracht und restlos
deinstalliert werden.
Auch können mit einfachen Mitteln definierte Installationen bzw.
Systemkonfigurationen erstellt werden.&lt;/p>
&lt;p>Unter OS X steht derzeit &lt;a href="http://brew.sh/">Homebrew&lt;/a> als Paketmanager mit
tausenden von (zumeist vorkompilierten) Paketen hoch in der Gunst der Nutzer.&lt;/p>
&lt;p>Doch was, wenn Benutzer Software wie
&lt;a href="https://de.wikipedia.org/wiki/Adobe_Photoshop">Photoshop&lt;/a>,
&lt;a href="https://www.omnigroup.com/omnigraffle">Omnigraffle&lt;/a> oder
&lt;a href="https://www.jetbrains.com/pycharm/">Pycharm&lt;/a> installiert brauchen?
Auch hier hilft Homebrew weiter: Mit der Erweiterung &lt;a href="https://github.com/Caskroom">HomebrewCask&lt;/a> kann Software aus externen Installern
auf das eigene System gebracht werden - automatisiert und nachvollziehbar.&lt;/p>
&lt;p>Hierzu ist nach der Installation von Homebrew lediglich ein Einbinden des
Homebrew Cask Repository notwendig:&lt;/p>
&lt;pre>&lt;code>brew tap caskroom/cask
&lt;/code>&lt;/pre>
&lt;p>Schon ist mit dem Befehl &lt;code>brew cask install firefox&lt;/code> der Firefox Browser im
eigenen System installiert werden.
Ist man auf &lt;em>nightly builds&lt;/em> oder &lt;em>alte&lt;/em> Versionen einer Software angewiesen,
hilft zu dem das optionale Repository &lt;code>caskroom/versions&lt;/code>.&lt;/p>
&lt;pre>&lt;code>brew tap caskroom/versions
&lt;/code>&lt;/pre>
&lt;p>Mit der Hilfe von &lt;a href="https://www.ansible.com/">Ansible&lt;/a> kann dieser Prozess
(sowie die Installation der Software) nun zentral erfolgen.&lt;/p>
&lt;p>Wir legen uns eine Konfiguration an.
Hierzu erstellen wir einen Tasks zur Installation von Homebrew Cask und allen Applikationen:
&lt;code>roles/apps/tasks/main.yml&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Check if homebrew cask installed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">homebrew&lt;/span>: &lt;span style="color:#ae81ff">name=cask state=present&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Check if caskroom/versions is installed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">homebrew_tap&lt;/span>: &lt;span style="color:#ae81ff">tap=caskroom/versions state=present&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- &lt;span style="color:#f92672">name&lt;/span>: &lt;span style="color:#ae81ff">Install applications&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">homebrew_cask&lt;/span>: &lt;span style="color:#ae81ff">name={{ item }} state=present&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">become&lt;/span>: &lt;span style="color:#66d9ef">yes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">with_items&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">firefox&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">vivaldi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#ae81ff">gimp&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ansible installiert beim Aufruf nun alle aufgezählten Applikationen.
Aber Achtung: Da Homebrew als Nutzer ausgeführt werden sollte, die Installation
mancher Applikationen jedoch Administrator-Rechte verlangt, ist es hier
sinnvoll, die beiden Tasks &lt;code>homebrew&lt;/code> und &lt;code>homebrew_tab&lt;/code> als Nutzer laufen zu
lassen, den &lt;code>homebrew_cask&lt;/code> Prozess jedoch als Administrator (Siehe
&lt;a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_privilege_escalation.html">become&lt;/a>).&lt;/p>
&lt;p>Nun haben wir die Möglichkeit zentral, dokumentiert und nachvollziehbar
Software zu installieren, die aus Installern stammt.&lt;/p></content></item><item><title>Kommandozeile mit FZF</title><link>https://philipp-weissmann.de/kommandozeile-mit-fzf/</link><pubDate>Fri, 22 Apr 2016 08:01:39 +0000</pubDate><guid>https://philipp-weissmann.de/kommandozeile-mit-fzf/</guid><description>&lt;p>Wer viel auf der Kommandozeile/Shell arbeitet, lernt im Lauf der Zeit einige nützliche Tools und Tastaturkürzel kennen.
So stöbert man in &lt;code>bash&lt;/code> bzw. &lt;code>zsh&lt;/code>mit &lt;code>Ctrl+R&lt;/code> in der Eingabe-History, sucht mit &lt;code>find&lt;/code> Dateien in einem gegeben Pfad - und so weiter und so fort.&lt;/p>
&lt;p>Ein nützliches Helferlein, welches die beiden Aktionen (und mehr) beschleunigt
ist &lt;a href="https://github.com/junegunn/fzf">&lt;code>fzf&lt;/code>&lt;/a>:&lt;/p></description><content>&lt;p>Wer viel auf der Kommandozeile/Shell arbeitet, lernt im Lauf der Zeit einige nützliche Tools und Tastaturkürzel kennen.
So stöbert man in &lt;code>bash&lt;/code> bzw. &lt;code>zsh&lt;/code>mit &lt;code>Ctrl+R&lt;/code> in der Eingabe-History, sucht mit &lt;code>find&lt;/code> Dateien in einem gegeben Pfad - und so weiter und so fort.&lt;/p>
&lt;p>Ein nützliches Helferlein, welches die beiden Aktionen (und mehr) beschleunigt
ist &lt;a href="https://github.com/junegunn/fzf">&lt;code>fzf&lt;/code>&lt;/a>:&lt;/p>
&lt;p>In &lt;a href="http://golang.org">Go&lt;/a> geschrieben und fix installiert (z.B. via Arch Linux Aur, zu Fuß oder als via Vim-Plugin) kann das Werkzeug händisch genutzt werden oder in Verbindung mit &lt;code>tmux&lt;/code> auch die oben genannten Tastaturkürzel übernehmen.&lt;/p>
&lt;p>Und so sieht das ganze aus:&lt;/p>
&lt;p>![Interaktives fzf][https://camo.githubusercontent.com/0b07def9e05309281212369b118fcf9b9fc7948e/68747470733a2f2f7261772e6769746875622e636f6d2f6a756e6567756e6e2f692f6d61737465722f667a662e676966]&lt;/p>
&lt;p>Jetzt erlaubt das Tool interaktiv und komfortabel nach Dateien zu suchen, alte Befehle aufzufinden und damit den Komfort des Arbeitens auf der Kommandozeile deutlich zu steigern.&lt;/p></content></item><item><title>Wget wiederaufnehmen</title><link>https://philipp-weissmann.de/wget-wiederaufnehmen/</link><pubDate>Wed, 13 Apr 2016 05:46:16 +0000</pubDate><guid>https://philipp-weissmann.de/wget-wiederaufnehmen/</guid><description>Beim Download großer Dateien (z.B. Iso-Images, Podcasts) ist es oft hilfreich einen bereits begonnenen Download weiterführen zu können.
Mit dem Download-Werkzeug wget ist dies einfach mit der Kommandozeilenoption -r möglich.
Damit man jedoch nicht immer daran denken muss, lässt sie dies auch als Standardverhalten einstellen.
Hierzu tragen wir die die Datei ~/.wgetrc folgendes ein:
continue = on Ab sofort nimmt wget Downloads automatisch wieder auf.</description><content>&lt;p>Beim Download großer Dateien (z.B. Iso-Images, Podcasts) ist es oft hilfreich einen bereits begonnenen Download weiterführen zu können.&lt;/p>
&lt;p>Mit dem Download-Werkzeug &lt;code>wget&lt;/code> ist dies einfach mit der Kommandozeilenoption &lt;code>-r&lt;/code> möglich.&lt;/p>
&lt;p>Damit man jedoch nicht immer daran denken muss, lässt sie dies auch als Standardverhalten einstellen.&lt;/p>
&lt;p>Hierzu tragen wir die die Datei &lt;code>~/.wgetrc&lt;/code> folgendes ein:&lt;/p>
&lt;pre>&lt;code>continue = on
&lt;/code>&lt;/pre>
&lt;p>Ab sofort nimmt &lt;code>wget&lt;/code> Downloads automatisch wieder auf.&lt;/p></content></item><item><title>Vollbackup mit rsync</title><link>https://philipp-weissmann.de/vollbackup-mit-rsync/</link><pubDate>Tue, 12 Apr 2016 13:04:04 +0000</pubDate><guid>https://philipp-weissmann.de/vollbackup-mit-rsync/</guid><description>&lt;p>Das Tool Nummer eins um Daten von A nach B zu spiegeln ist &lt;code>rsync&lt;/code>.&lt;br>
Es kann über Rechnergrenzen hinweg eingesetzt werden (z.B. via &lt;code>ssh&lt;/code>), beherrscht inkrementelles Kopieren und vieles mehr.&lt;/p></description><content>&lt;p>Das Tool Nummer eins um Daten von A nach B zu spiegeln ist &lt;code>rsync&lt;/code>.&lt;br>
Es kann über Rechnergrenzen hinweg eingesetzt werden (z.B. via &lt;code>ssh&lt;/code>), beherrscht inkrementelles Kopieren und vieles mehr.&lt;/p>
&lt;p>Um einen (Linux) Rechner vollständig zu sichern nutze ich zumeist:&lt;/p>
&lt;pre>&lt;code>rsync -aAXv --exclude={\
&amp;quot;/dev/*&amp;quot;,&amp;quot;/proc/*&amp;quot;,&amp;quot;/sys/*&amp;quot;,&amp;quot;/tmp/*&amp;quot;,\
&amp;quot;/run/*&amp;quot;,&amp;quot;/mnt/*&amp;quot;,&amp;quot;/media/*&amp;quot;,&amp;quot;/lost+found&amp;quot;\
} / /path/to/backup/folder
&lt;/code>&lt;/pre>
&lt;p>Der Befehl kopiert alle Dateien (mit Ausnahme der Verzeichnisse in der Aufzählung) - und das inkrementell.&lt;br>
Abbrechen und Wiederaufnehmen ist also problemlos möglich.&lt;/p>
&lt;p>Damit wird rsync zum perfekten Tool um eine Vollsicherung vor einer Neuinstallation vorzunehmen.&lt;/p></content></item><item><title>Myrepos: Alle meine Repositories</title><link>https://philipp-weissmann.de/myrepos-alle-meine-repositories/</link><pubDate>Sun, 17 May 2015 13:15:05 +0000</pubDate><guid>https://philipp-weissmann.de/myrepos-alle-meine-repositories/</guid><description>&lt;h1 id="repository-zentrale">Repository-Zentrale&lt;/h1>
&lt;p>Dank VCSH habe ich all meine Dotfiles hübsch in Git-Repositories verpackt.&lt;br>
Das Einbinden eines einzelnen Repositories geht nun zwar schnell von der Hand,&lt;br>
aber wenn nun für &lt;code>vim&lt;/code> und &lt;code>mutt&lt;/code> und &lt;code>emacs&lt;/code> und und und &amp;hellip; lauter&lt;br>
Repositories vorliegen wird es unbequem.&lt;br>
Auch das updaten (&lt;code>pull&lt;/code>) jedes einzelnen Repos ist sehr mühselig und damit&lt;br>
fehleranfällig.&lt;/p>
&lt;p>Abhilfe schafft hier &lt;a href="https://myrepos.branchable.com/">myrepos&lt;/a> (kurz &lt;code>mr&lt;/code>),&lt;br>
dass es erlaubt Aktionen auf mehreren Repositories auszuführen.&lt;/p></description><content>&lt;h1 id="repository-zentrale">Repository-Zentrale&lt;/h1>
&lt;p>Dank VCSH habe ich all meine Dotfiles hübsch in Git-Repositories verpackt.&lt;br>
Das Einbinden eines einzelnen Repositories geht nun zwar schnell von der Hand,&lt;br>
aber wenn nun für &lt;code>vim&lt;/code> und &lt;code>mutt&lt;/code> und &lt;code>emacs&lt;/code> und und und &amp;hellip; lauter&lt;br>
Repositories vorliegen wird es unbequem.&lt;br>
Auch das updaten (&lt;code>pull&lt;/code>) jedes einzelnen Repos ist sehr mühselig und damit&lt;br>
fehleranfällig.&lt;/p>
&lt;p>Abhilfe schafft hier &lt;a href="https://myrepos.branchable.com/">myrepos&lt;/a> (kurz &lt;code>mr&lt;/code>),&lt;br>
dass es erlaubt Aktionen auf mehreren Repositories auszuführen.&lt;/p>
&lt;h1 id="installation">Installation&lt;/h1>
&lt;p>Wir installieren uns das Paket &lt;code>myrepos&lt;/code> via &lt;code>apt-get&lt;/code> oder &lt;code>yaourt&lt;/code>&lt;/p>
&lt;p>Installation unter Debian/Ubuntu:&lt;/p>
&lt;pre>&lt;code>sudo apt-get install myrepos
&lt;/code>&lt;/pre>
&lt;p>oder unter Arch Linux&lt;/p>
&lt;pre>&lt;code>yaourt -S myrepos
&lt;/code>&lt;/pre>
&lt;h1 id="basis-konfiguration">Basis-Konfiguration&lt;/h1>
&lt;p>Wir legen eine Konfigurationsdatei mit dem Namen &lt;code>~/.mrconfig&lt;/code> an mit folgendem&lt;br>
Inhalt:&lt;/p>
&lt;pre>&lt;code>[DEFAULT]
git_gc = git gc &amp;quot;$@&amp;quot;
jobs = 1
include = cat ~/.config/mr/config.d/*
&lt;/code>&lt;/pre>
&lt;p>Wenn nach allen Schritten die Konfiguration zuverlässig installiert können wir&lt;br>
die Anzahl der parallelen Jobs auf z.B. 4 erhöhen.&lt;/p>
&lt;p>Nun legen wir folgende Verzeichnisse an:&lt;/p>
&lt;pre>&lt;code>mkdir -p ~/.config/mr/config.d
mkdir ~/.config/mr/available.d
&lt;/code>&lt;/pre>
&lt;p>In das Verzeichnis &lt;code>available.d&lt;/code> legen wir alle Konfigurationsdateien ab.&lt;/p>
&lt;p>Eine solche Konfigurationsdatei enthält den Ort Zielort des Repositories&lt;br>
und auch die Anweisung, woher die Quelle kommt.&lt;/p>
&lt;p>Die Datei für eine &lt;code>vim&lt;/code>-VCSH-Konfiguration könnte z.B. so aussehen:&lt;/p>
&lt;p>Dateiname: &lt;code>vim.vcsh&lt;/code>&lt;/p>
&lt;pre>&lt;code>[$HOME/.config/vcsh/repo.d/vim.git]
checkout = vcsh clone git@MEINGITSERVER:vim vim
&lt;/code>&lt;/pre>
&lt;p>Dabei kann myrepos vcsh oder direkt git oder auch subversion (u.v.m.) nutzen.&lt;/p>
&lt;p>Nun linke (&lt;code>ln -s&lt;/code>) ich noch alle die Konfigurationsdateien nach &lt;code>available.d&lt;/code>,&lt;br>
die auch wirklich auf all meinen Systemen nutzen möchte.&lt;/p>
&lt;p>Mit dem Aufruf&lt;/p>
&lt;pre>&lt;code>mr up
&lt;/code>&lt;/pre>
&lt;p>Aktualisiere (z.B. bei git: pull) ich nun alle Repositories, die ich via&lt;br>
myrepos verwalte. Somit kann ich beim Wechsel von Rechnern einfach meine&lt;br>
Konfiguration aktualisieren.&lt;/p>
&lt;p>Auch pushen von allen Repositories ist möglich:&lt;/p>
&lt;pre>&lt;code>mr push
&lt;/code>&lt;/pre>
&lt;p>usw.&lt;/p>
&lt;h1 id="myrepos-in-vcsh">Myrepos in VCSH&lt;/h1>
&lt;p>Auch die Konfiguration von myrepos selbst verwalte ich mit vcsh (und&lt;br>
wiederum mit Datei-Eintrag in myrepos), so dass sich auch beim Hinzukommen&lt;br>
von neuen Repositories ich diese auf meinen Geräten erhalte.&lt;/p>
&lt;h1 id="neuer-rechner---einfacher-schritt">Neuer Rechner - einfacher Schritt&lt;/h1>
&lt;p>Bei einem neuen Rechner sind nun extrem wenige Schritte notwendig:&lt;/p>
&lt;ol>
&lt;li>Installieren von vcsh und myrepos (gibt es zumeist im Paketmanager)&lt;/li>
&lt;li>Klonen des myrepos vcsh repositories (d.h. &lt;code>vcsh clone git@MEINGITSERVER:mr mr&lt;/code>)&lt;/li>
&lt;li>Klonen aller weiteren Repos via &lt;code>mr up&lt;/code>&lt;/li>
&lt;/ol>
&lt;h1 id="sonderfälle">Sonderfälle&lt;/h1>
&lt;p>Auch einfache Programme (z.B. &lt;a href="https://rg3.github.io/youtube-dl/">youtube-dl&lt;/a>)&lt;br>
installiere (und update) ich via myrepos: Hierzu leg ich ich wieder eine&lt;br>
Konfigurationsdatei an (z.B. &lt;code>youtube-dl.git&lt;/code>) mit folgendem Inhalt:&lt;/p>
&lt;pre>&lt;code>[$HOME/.local/opt/youtube-dl.git]
checkout = git clone https://github.com/rg3/youtube-dl.git $HOME/.local/opt/youtube-dl.git
push = echo &amp;quot;No pushing to public repo&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Der &lt;code>push&lt;/code> Befehl wird hier explizit überschrieben und gibt bei &lt;code>mr push&lt;/code> einfach die&lt;br>
Nachricht aus, dass ich in dieses Repository nicht pushen möchte.&lt;/p>
&lt;h1 id="fazit">Fazit&lt;/h1>
&lt;p>Myrepos ermöglicht das einfache und bequeme Verwalten und Nutzen von vielen&lt;br>
Repositories. Gerade das Updaten oder initiale Klonen wird damit deutlich&lt;br>
bequemer. Insbesondere im Zusammenspiel mit VCSH wird eine extrem komfortable&lt;br>
Verwaltung der eigenen Dotfiles (und mehr) möglich.&lt;/p></content></item><item><title>OS X Keyboard Layout</title><link>https://philipp-weissmann.de/keyboard-layout/</link><pubDate>Sun, 26 Apr 2015 13:35:47 +0000</pubDate><guid>https://philipp-weissmann.de/keyboard-layout/</guid><description>&lt;h1 id="das-problem">Das Problem&lt;/h1>
&lt;p>Als Entwickler nutze ich stetig Sonderzeichen und Symbole wie {, ] oder auch `.&lt;/p>
&lt;p>Doch welches Tastaturlayout soll ich einsetzen?
Zwar ist ein englisches Tastaturlayout sehr attraktiv, da dort sämtliche Sonderzeichen gut erreichbar sind. Als Entwickler im deutschsprachigen Raum benötige ich jedoch ständig Umlaute und das &lt;em>ß&lt;/em>-Zeichen.&lt;/p></description><content>&lt;h1 id="das-problem">Das Problem&lt;/h1>
&lt;p>Als Entwickler nutze ich stetig Sonderzeichen und Symbole wie {, ] oder auch `.&lt;/p>
&lt;p>Doch welches Tastaturlayout soll ich einsetzen?
Zwar ist ein englisches Tastaturlayout sehr attraktiv, da dort sämtliche Sonderzeichen gut erreichbar sind. Als Entwickler im deutschsprachigen Raum benötige ich jedoch ständig Umlaute und das &lt;em>ß&lt;/em>-Zeichen.&lt;/p>
&lt;p>Bei der Nutzung eines deutschen Tastaturlayout finde ich jedoch Symbole wie &lt;em>{&lt;/em> extrem Umständlich zu erreichen.&lt;/p>
&lt;p>Sonderbelegungen wie &lt;a href="https://de.wikipedia.org/wiki/Dvorak-Tastaturbelegung">Dvorak&lt;/a> sind zwar reizvoll, scheitern aber für mich an der Tatsache, dass die
Umgewöhnung bei der Nutzung eines fremden Rechners zu hoch wäre.&lt;/p>
&lt;h1 id="lösung">Lösung&lt;/h1>
&lt;p>Daher habe ich mir für OS X ein eigenes Tastaturlayout gebaut.
Dieses nutzt als Basis das US-Englische Layout, nutzt jedoch die Alt-Taste für &amp;ldquo;deutsche&amp;rdquo; Sonderzeichen.&lt;/p>
&lt;p>So erzeugt &lt;code>Alt + [&lt;/code> das &lt;em>ü&lt;/em> Zeichen.
Ich drücke also genau die Taste, die bei einem deutschen Keyboard ebenfalls das &lt;em>ü&lt;/em> erzeugt.&lt;/p>
&lt;p>Somit fällt die Umgewöhnung auf die neue Eingabeform extrem leicht.&lt;/p>
&lt;h1 id="installation">Installation&lt;/h1>
&lt;p>Das Layout ist einfach zu installieren - es kann direkt von der &lt;a href="https://github.com/derphilipp/english_keyboard_for_germans/releases">Projektseite auf Github&lt;/a> herunterladen werden.&lt;/p>
&lt;p>Wie in der &lt;a href="https://github.com/derphilipp/english_keyboard_for_germans/">Anleitung&lt;/a> beschrieben, muss nach dem Entpacken der Datei diese lediglich in das Verzeichnis&lt;/p>
&lt;pre>&lt;code>~/Library/Keyboard Layouts
&lt;/code>&lt;/pre>
&lt;p>kopiert werden und in dem Punkt
&lt;em>Systemeinstellungen&lt;/em> -&amp;gt; &lt;em>Tastatur&lt;/em> -&amp;gt; &lt;em>Eingabequellen&lt;/em>
aktiviert werden.&lt;/p>
&lt;h1 id="fazit">Fazit&lt;/h1>
&lt;p>Nach kurzer Umgewöhnungszeit ist es mir nun möglich das komfortable englische Tastaturlayout zu nutzen, ohne jedoch auf die native Eingabemöglichkeit Umlauten und Co zu verzichten.&lt;/p></content></item><item><title>Shift Lock sinnvoll nutzen</title><link>https://philipp-weissmann.de/shift-lock-sinnvoll-nutzen/</link><pubDate>Tue, 21 Apr 2015 19:01:17 +0000</pubDate><guid>https://philipp-weissmann.de/shift-lock-sinnvoll-nutzen/</guid><description>&lt;h1 id="shift-lock">Shift-Lock&lt;/h1>
&lt;p>Die Shift-Lock Taste alias &amp;ldquo;Feststelltaste&amp;rdquo; ist für die meisten Menschen ein Ärgernis und&lt;br>
Relikt aus der Zeit der Schreibmaschinen.&lt;/p>
&lt;p>Doch anstatt die Taste zu deaktivieren oder gar auszubauen kann die Taste auch gut für andere&lt;br>
Zwecke verwendet werden.&lt;/p>
&lt;p>Ich habe die Shift-Lock Taste auf die &amp;ldquo;Ctrl&amp;rdquo; (Steuerung) Taste gemappt, was Shortcuts wie &lt;em>Ctrl+C&lt;/em> in vim deutlich attraktiver macht&lt;/p>
&lt;h1 id="so-gehts">So gehts&lt;/h1></description><content>&lt;h1 id="shift-lock">Shift-Lock&lt;/h1>
&lt;p>Die Shift-Lock Taste alias &amp;ldquo;Feststelltaste&amp;rdquo; ist für die meisten Menschen ein Ärgernis und&lt;br>
Relikt aus der Zeit der Schreibmaschinen.&lt;/p>
&lt;p>Doch anstatt die Taste zu deaktivieren oder gar auszubauen kann die Taste auch gut für andere&lt;br>
Zwecke verwendet werden.&lt;/p>
&lt;p>Ich habe die Shift-Lock Taste auf die &amp;ldquo;Ctrl&amp;rdquo; (Steuerung) Taste gemappt, was Shortcuts wie &lt;em>Ctrl+C&lt;/em> in vim deutlich attraktiver macht&lt;/p>
&lt;h1 id="so-gehts">So gehts&lt;/h1>
&lt;h2 id="windows">Windows&lt;/h2>
&lt;p>Unter Windows erstellen wir eine Datei mit der Endung .reg, z.B. &lt;code>shift.reg&lt;/code> mit folgendem Inhalt:&lt;/p>
&lt;pre>&lt;code> REGEDIT4
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout]
&amp;quot;Scancode Map&amp;quot;=hex:00,00,00,00,00,00,00,00,02,00,00,00,1d,00,3a,00,00,00,00,00
&lt;/code>&lt;/pre>
&lt;p>Nach dem Importieren in die Registry (i.d.R. Doppellick auf die neue Datei) und einem Neustart sollte die Tastet nun die neue Funktion haben.&lt;/p>
&lt;h2 id="os-x">OS X&lt;/h2>
&lt;p>Unter OS X fällt die Einstellung etwas einfacher aus:&lt;br>
In den &amp;ldquo;System Preferences&amp;rdquo; wählen wir den Punkt &amp;ldquo;Keyboard&amp;rdquo; aus.&lt;br>
Dort, im Reiter &amp;ldquo;Keyboard&amp;rdquo;, befindet sich ein Knopf namens &amp;ldquo;Modifier Keys&amp;hellip;&amp;rdquo;.&lt;/p>
&lt;p>Hier können wir die Belegung von &amp;ldquo;Caps Lock&amp;rdquo; (d.h. Shift Lock), &amp;ldquo;Control&amp;rdquo;, &amp;ldquo;Option&amp;rdquo; und auch &amp;ldquo;Command&amp;rdquo; ändern.&lt;/p>
&lt;p>Achtung: Diese Einstellung ist nur für das aktuelle Keyboard gültig, d.h. bei&lt;br>
Notebook mit externer Tastatur muss diese Einstellung sowohl für die eingebaute als auch die externe Tastatur durchgeführt werden.&lt;/p>
&lt;h2 id="linux-bsd-ua">Linux, BSD, u.a.&lt;/h2>
&lt;p>Unter Linux/BSD kann diese Einstellung oftmals in den jeweiligen Systemwerkzeugen getroffen werden.&lt;br>
Eine &amp;ldquo;eher universale&amp;rdquo; Möglichkeit für X ergibt sich mit folgendem Befehl:&lt;/p>
&lt;pre>&lt;code>setxkbmap -option ctrl:nocaps
&lt;/code>&lt;/pre>
&lt;h1 id="fazit">Fazit&lt;/h1>
&lt;p>Mit geringem Aufwand kann man die &amp;ldquo;nervige&amp;rdquo; Shift-Lock Taste in eine wertvolle Taste&lt;br>
verwandeln.&lt;br>
Nach etwas Umgewöhnung nutze ich die &amp;ldquo;normale&amp;rdquo; Control Taste praktisch gar nicht mehr und bei der Nutzung von &lt;code>vim&lt;/code> gehen Shortcuts wie &lt;em>Ctrl+C&lt;/em>&lt;br>
(in den &lt;em>normal mode&lt;/em> wechseln) und &lt;em>Ctrl+V&lt;/em> (&lt;em>visual block mode&lt;/em>) deutlich leichter von der Hand.&lt;/p></content></item><item><title>Konfigurationsdateien verwalten mit VCSH</title><link>https://philipp-weissmann.de/konfigurationsdateien-verwalten-mit-vcsh/</link><pubDate>Sun, 19 Apr 2015 17:32:15 +0000</pubDate><guid>https://philipp-weissmann.de/konfigurationsdateien-verwalten-mit-vcsh/</guid><description>Einstellungen Was ist der erste Schritt bei der Benutzung eines Autos, einer Stereoanlage oder eines Schreibtischstuhls?
Die Einstellungen!
Natürlich will man gut aus dem Fahrzeug sehen können, der Lieblings-Musik lauschen und bequem sitzen.
Doch auch Software hat Einstellungen:
Welchen Editor setze ich als Standard? Welche Shell-Erweiterungen lade ich in oh-my-zsh? Welches color-theme lade ich in vim? Welche Accounts habe ich in mutt? Praktischerweise liegen all diese Einstellungen in Dateien (sogenannten &amp;ldquo;Dotfiles&amp;rdquo;), welche sich einfach von A nach B kopieren lassen.</description><content>&lt;h1 id="einstellungen">Einstellungen&lt;/h1>
&lt;p>Was ist der erste Schritt bei der Benutzung eines Autos, einer Stereoanlage oder eines Schreibtischstuhls?&lt;br>
Die Einstellungen!&lt;br>
Natürlich will man gut aus dem Fahrzeug sehen können, der Lieblings-Musik lauschen und bequem sitzen.&lt;/p>
&lt;p>Doch auch Software hat Einstellungen:&lt;/p>
&lt;ul>
&lt;li>Welchen Editor setze ich als Standard?&lt;/li>
&lt;li>Welche Shell-Erweiterungen lade ich in &lt;code>oh-my-zsh&lt;/code>?&lt;/li>
&lt;li>Welches &lt;code>color-theme&lt;/code> lade ich in vim?&lt;/li>
&lt;li>Welche Accounts habe ich in &lt;code>mutt&lt;/code>?&lt;/li>
&lt;/ul>
&lt;p>Praktischerweise liegen all diese Einstellungen in Dateien (sogenannten &amp;ldquo;Dotfiles&amp;rdquo;), welche sich einfach von A nach B kopieren lassen.&lt;br>
Da ich jedoch regelmässig auf unterschiedlichen Rechnern arbeite, möchte ich diese aktuell halten.&lt;/p>
&lt;h1 id="dropbox">Dropbox&lt;/h1>
&lt;p>Mein erster Ansatz war es, alle Dateien in einen zentralen Dropbox Ordner zu verschieben und Links zu erstellen nach folgendem Schema&lt;/p>
&lt;pre>&lt;code>~/.vimrc -&amp;gt; ~/Dropbox/config/vimrc
&lt;/code>&lt;/pre>
&lt;p>Meine &lt;code>.vimrc&lt;/code> wurde durch den Dropbox-Dienst nun auf allen Rechnern synchronisiert und immer aktuell.&lt;br>
Richtete ich einen neuen Rechner ein, so musste ich &amp;ldquo;nur&amp;rdquo; Dropbox und den Link erstellen.&lt;/p>
&lt;p>Dieser Ansatz hat jedoch einige Nachteile:&lt;/p>
&lt;ol>
&lt;li>Ich bin von der Verfügbarkeit von Dropbox abhängig (ist ok für mich)&lt;/li>
&lt;li>Ich muss auf allen Rechnern Dropbox installieren (ist auch noch so ok)&lt;/li>
&lt;li>Ich muss alle Dateien händisch verlinken (nicht ok!)&lt;/li>
&lt;li>Die Änderungen sind nicht dokumentiert bzw. haben keine definierten Zwischenstände (nicht ok!)&lt;/li>
&lt;li>Alle Änderungen werden sofort bei allen Systemen aktualisiert (außer ich stoppe Dropbox)&lt;/li>
&lt;/ol>
&lt;h1 id="vcsh">VCSH&lt;/h1>
&lt;p>Ich wünschte mir ein System, welches die Versionierung der Konfigurationsdaten übernimmt und bin dabei auf VCHS gestoßen.&lt;/p>
&lt;p>Das schöne an VCSH: Es baut einfach auf git auf und bietet somit einerseits ein vertrautes Interface. Zudem kann ich meine Konfigurationsdateien nun einfach in ein zentrales Repository (z.B. auf Github oder auf einem eigenen Server) ablegen.&lt;/p>
&lt;h2 id="installieren">Installieren&lt;/h2>
&lt;p>Installieren erfolgt aus dem Repository, Debian/Ubuntu also per&lt;/p>
&lt;pre>&lt;code>apt-get install vcsh
&lt;/code>&lt;/pre>
&lt;p>oder bei Arch Linux via aur (hier mit yaourt)&lt;/p>
&lt;pre>&lt;code>yaourt -S vcsh
&lt;/code>&lt;/pre>
&lt;h2 id="anlegen">Anlegen&lt;/h2>
&lt;p>Ich empfehle pro Werkzeug (z.B. emacs, mutt, &amp;hellip;) ein eigenes Repository anzulegen um die Übersicht zu behalten.&lt;br>
Die Syntax hierbei entspricht der von git, jedoch mit Namen des Werkzeugs vorangestellt, also &lt;code>vcsh WERKZEUG GIT-BEFEHL&lt;/code> (Ausnahme: &lt;code>init&lt;/code>-Befehl)&lt;/p>
&lt;p>Wir initialisieren uns erstmal ein Repository für unsere Vim-Einstellungen&amp;hellip;&lt;/p>
&lt;pre>&lt;code>vcsh init vim
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; fügen die Datei(en) hinzu, die wir verwalten wollen &amp;hellip;&lt;/p>
&lt;pre>&lt;code>vcsh vim add ~/.vimrc
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; machen unseren ersten commit &amp;hellip;&lt;/p>
&lt;pre>&lt;code>vcsh vim commit -m &amp;quot;Mein erster Vim-commit&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; und pushen diesen auf unseren Git-Server (z.B. Github)&lt;/p>
&lt;pre>&lt;code>vcsh vim remote add git@MEINGITSERVER:vim.git
vcsh vim push -u origin master
&lt;/code>&lt;/pre>
&lt;h2 id="klonen">Klonen&lt;/h2>
&lt;p>Auf einem neuen Rechner können wir uns die Konfiguration einfach holen:&lt;/p>
&lt;pre>&lt;code>vcsh clone git@MEINGISERVER:vim.git
&lt;/code>&lt;/pre>
&lt;h2 id="gitignore">.gitignore&lt;/h2>
&lt;p>Da sich unsere Konfigurationsdateien im Home-Verzeichnis des Users befinden, hat VCSH (bzw. git) keine Chance zu wissen welche Dateien definitiv zu dem Projekt gehören und welche nicht.&lt;br>
Also schaffen wir mit einer .gitignore-Datei Abhilfe: Alle Dateien und Verzeichnisse sollen ignoriert werden, außer den Projektdateien/Ordnern.&lt;br>
Diese erstellen wir automatisch via&lt;/p>
&lt;pre>&lt;code>vcsh write-gitignore vim
&lt;/code>&lt;/pre>
&lt;p>Wie fügen die ignore-Datei selbst auch dem Projekt hinzu&amp;hellip;&lt;/p>
&lt;pre>&lt;code>vcsh vim add -f ~/.gitignore.d/vim
&lt;/code>&lt;/pre>
&lt;p>&amp;hellip; und schreiben die Datei erneut.&lt;/p>
&lt;pre>&lt;code>vcsh write-gitignore vim
&lt;/code>&lt;/pre>
&lt;p>Nun kontrollieren wir die Datei &lt;code>~/.gitignore.d/vim&lt;/code> ob sie nicht Dateien ignoriert, welche wir versionieren wollen;&lt;br>
Wenn nicht: Ab damit ins Repository!&lt;/p>
&lt;pre>&lt;code>vcsh vim add ~/.gitignore.d/vim
&lt;/code>&lt;/pre>
&lt;p>Alle weiteren Aktionen können wir nun in gewohnter git-manier (commit push pull) erledigen.&lt;/p>
&lt;h1 id="fazit">Fazit&lt;/h1>
&lt;p>VCSH erlaubt es bequem Dotfiles zu organisieren und diese versioniert abzulegen.&lt;br>
Im Alltag hilft mir es enorm meine Konfigurationsdateien auf einem Stand zu halten und Änderungen dokumentiert.&lt;/p>
&lt;p>Ergänzend zu VCSH bietet sich die Benutzung von &lt;code>myrepos&lt;/code> ab um mehrere Repositories gleichzeitig zu verwalten.&lt;/p></content></item></channel></rss>